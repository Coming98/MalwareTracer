import json
import os
import re
from xml.dom import minidom

def generate_file_type(exinfo_list, acceptFileTypes):
    file_name, file_type = None, None
    for exinfo in exinfo_list:
        if("NamedPipe" in exinfo):
            file_name = exinfo.split('\\')[-1]
            file_type = "Pipe" # f"Pipe-{pipename}"
        else:
            file_name = exinfo.split("\\")[-1]
            for type in file_name.split('.'):
                if(type.upper() in acceptFileTypes):
                    file_type = type.upper()
                    break

    return file_name, file_type

def generate_exe_name(exinfo_list):
    for exinfo in exinfo_list:
        res = re.search(r"[a-zA-Z0-9]*?.exe", exinfo)
        if(res): return res.group()
        else: res = re.search(r"([a-zA-Z0-9]*?) -p", exinfo)
        
        if(res): return res.groups()[0] + ".exe"
    return None

def generate_exe_names(exinfo_list):
    exe_names = []
    for exinfo in exinfo_list:
        res = re.search(r"[a-zA-Z0-9]*?.exe", exinfo)
        if(res): exe_names.append(res.group())
        else: 
            res = re.search(r"([a-zA-Z0-9]*?) -p", exinfo)
            if(res): exe_names.append(res.groups()[0] + ".exe")
    if(len(exe_names) == 2): return exe_names
    
    return None

def generate_pid_value(exinfo_list):
    for exinfo in exinfo_list:
        if(exinfo.isdigit()): return exinfo
        if(exinfo in ["-1414676753"]):
            print("手动过滤测试")
            return "IGNORE"
    return None

def generate_pid_value_by_exe_name(exe_name, exe2pid, next=False):
    accept_pids = exe2pid[exe_name]["value"]
    idx = exe2pid[exe_name]["idx"]
    if(idx >= len(accept_pids) - 1):
        print("推测为记录末尾，未记录后续行文，手动忽略测试")
        return "IGNORE"
    else:
        if(next):
            exe2pid[exe_name]["idx"] = idx + 1
            return accept_pids[idx + 1]
        else:
            if(idx == -1): return exe_name
            else: return accept_pids[idx]


def check_exinfo_value(value):
    value = value.split(';')[0]
    value = value.replace("&quot;", "")
    value = value.replace("\"", "").strip()
    return value

def get_exinfo_list(action):
    exinfo_list = []

    exinfo_tags = action.getElementsByTagName("exInfo")
    for exinfo_tag in exinfo_tags:
        value = exinfo_tag.getAttribute("value")
        value = check_exinfo_value(value)
        if(value): exinfo_list.append(value)
    
    return exinfo_list if exinfo_list else None

def parse_sequence_by_xml(config, input_path):
    file = minidom.parse(input_path)
    actions = file.getElementsByTagName("action")
    nodes, edges = [], []

    writed_file_names = []
    exe2pid = {}
    local_pids = []
    for action in actions:
        exe_name = action.getAttribute("call_name").strip()
        pid = action.getAttribute("call_pid").strip()
        if(pid not in local_pids): local_pids.append(pid)
        if(exe_name and len(exe_name) > 0):
            if exe_name not in exe2pid: exe2pid[exe_name] = {"value": [], "idx" :-1}
            if(pid not in exe2pid[exe_name]["value"]):
                exe2pid[exe_name]["value"].append(pid)

    for index, action in enumerate(actions):
        api_name = action.getAttribute("api_name")
        call_name = action.getAttribute("call_name")
        call_pid = action.getAttribute("call_pid")

        if(api_name not in config.api2cat): continue

        exinfo_list = get_exinfo_list(action)

        if(exinfo_list is None): continue

        if(len(edges) == 0):
            nodes.append(call_name)
            edges.append((call_name, "Execute", call_pid))

        infos = config.api2cat[api_name]
        if(infos["target"] == "File"): 
            target_filename, target = generate_file_type(exinfo_list, config.acceptFileTypes)
            if(target_filename is None): continue
            if(infos['cat'] == "Read" and target_filename not in writed_file_names): continue
            if(infos['cat'] == "Write"): writed_file_names.append(target_filename)
            if(target is None): target = "File"
            elif("Pipe" in target): 
                if(target not in nodes): nodes.append(target)
            elif("exe" in target.lower()):
                if(target not in exe2pid): target = "EXE"
        elif(infos["target"] == "pid"):
            if(infos["cat"] == "Fork"):
                # Fork 类的需要从 exinfo 中提取 exe name 然后在从 exe2pid 中获取 pid
                target_exe_name = generate_exe_name(exinfo_list)
                target = generate_pid_value_by_exe_name(target_exe_name, exe2pid, next=True)
            else:
                # 其余的 exinfo 参数中带有 pid，提取不出来则忽略
                target = generate_pid_value(exinfo_list)
                if(target == "0"):
                    target = generate_exe_name(exinfo_list)
                elif(target not in local_pids):
                    target = "EXE"
            if(target is None): raise ValueError(f"Wrong API Arguments: \n{action}")
            elif(target == "IGNORE"): continue
        elif(infos["target"] == "Cname"):
            target = call_name
            if(call_name not in nodes): nodes.append(call_name)
        elif(infos["target"] == "2way"):
            exe_names = generate_exe_names(exinfo_list)
            pid_values = [ generate_pid_value_by_exe_name(exe_name, exe2pid, next=False)  if exe_name in exe2pid else "EXE" for exe_name in exe_names ]
            insert_edge = (pid_values[0], "Read", call_pid)
            if(insert_edge not in edges): edges.append(insert_edge)
            insert_edge = (call_pid, "Write", pid_values[1])
            if(insert_edge not in edges): edges.append(insert_edge)
            continue
        else:
            target = infos["target"]

        _source, _target = call_pid, target
        if(infos["dir"] == 'in'): _source, _target = _target, _source
        insert_edge = (_source, infos["cat"], _target)
        if(insert_edge not in edges): edges.append(insert_edge)

    return nodes, edges


def generate_process_name(command_line, default):

    res = re.search("[a-zA-Z0-9_]*?.exe", command_line)
    if(res): return res.group()
    else: return default

def parse_sequence_by_json(config, input_path):
    with open(input_path, 'r') as f:
        json_data = json.load(f)

    nodes, edges, edges_call_time = [], [], []
    
    for source_process in json_data["behavior"]["processes"]:
        source_process_name = source_process["process_path"].split("\\")[-1]
        source_process_id = str(source_process["pid"])

        nodes.append(source_process_name)
        edges.append((source_process_name, "Execute", source_process_id))
        edges_call_time.append(-1 if(len(edges_call_time) == 0) else edges_call_time[-1])  

        calls = source_process["calls"]
        execute_edge = None
        for call in calls:
            api_name = call["api"]
            api_call_time = call["time"]
            
            if(api_name not in config.api2cat): continue
            info = config.api2cat[api_name]

            target_process = "NONE"
            arguments = call["arguments"]
            if(info["target"] == "pid"):
                target_process_id = str(arguments["process_identifier"])
                target_process = target_process_id

                if(info["cat"] == "Fork"):
                    # Fork 后自动补充 Execute
                    target_process_name = generate_process_name(arguments["command_line"], target_process_id)
                    execute_edge = (target_process_name, "Execute", target_process_id)
            else:
                target_process = info["target"]

            # source_process_name  info["cat"] target_process_name
            _source, _target = source_process_id, target_process
            if(info["dir"] == "in"): _source, _target = _target, _source

            insert_edge = (_source, info["cat"], _target)
            if(insert_edge not in edges): 
                edges.append(insert_edge)
                edges_call_time.append(api_call_time)
                if(execute_edge):
                    edges.append(execute_edge)
                    edges_call_time.append(api_call_time)
                    execute_edge = None


    edges = [(*edge, time) for edge, time in zip(edges, edges_call_time)]
    edges.sort(key=lambda item: item[-1])

    ret_edges = []
    for edge in edges:
        source, api_cat, target, _ = edge
        ret_edges.append((source, api_cat, target))

    return nodes, ret_edges


def parse_sequence(config, input_path, input_name, input_type):

    if(input_type == 'xml'):
        return parse_sequence_by_xml(config, input_path)
    elif(input_type == 'json'):
        return parse_sequence_by_json(config, input_path)
    

def main(config, input_path, input_name, input_type, output_dir):

    # 解析文件生成边缘关系与节点属性
    nodes, edges = parse_sequence(config, input_path, input_name, input_type)

    # json_dump
    json_data = {"nodes": nodes, "edges": edges}
    output_path = os.path.join(output_dir, f"{input_name}.idata.json")
    with open(output_path, 'w') as f:
        json.dump(json_data, f)
    
    return output_path

    